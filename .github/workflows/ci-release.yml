name: Build & Release (multi-platform)

on:
  release:
    types: [published]
  workflow_dispatch:

permissions:
  contents: write # needed to create releases and upload assets

env:
  PKG_NAME: sstp-client
  TAG: nightly

jobs:
  build:
    name: Build ${{ matrix.name }}
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: ubuntu-24.04-amd64
            runner: ubuntu-24.04
            arch: amd64
            target: x86_64-unknown-linux-gnu
            ext: tar.gz
          - name: ubuntu-24.04-arm64
            runner: ubuntu-24.04-arm
            arch: arm64
            target: aarch64-unknown-linux-gnu
            ext: tar.gz
          - name: macos-amd64
            runner: macos-15-intel
            arch: amd64
            target: x86_64-apple-darwin
            ext: tar.gz
          - name: macos-arm64
            runner: macos-latest
            arch: arm64
            target: aarch64-apple-darwin
            ext: tar.gz

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Set version
        id: vars
        shell: bash
        run: |
          if [[ "$GITHUB_EVENT_NAME" == "release" ]]; then
            TAG=$(jq -r .release.tag_name < "$GITHUB_EVENT_PATH")
            echo "version=$TAG" >> $GITHUB_OUTPUT
            echo "is_release=true" >> $GITHUB_OUTPUT
          else
            VER="${GITHUB_RUN_NUMBER}-nightly"
            echo "version=$VER" >> $GITHUB_OUTPUT
            echo "is_release=false" >> $GITHUB_OUTPUT
          fi

      - name: Install build dependencies
        shell: bash
        run: |
          if [[ "$(uname)" == "Linux" ]]; then
            sudo apt-get update
            sudo apt-get install -y build-essential automake libtool pkg-config libssl-dev ca-certificates curl jq wget xz-utils libevent-dev

            # Ensure autoconf >= 2.72 (Ubuntu images may ship older versions).
            REQUIRED_AUTOCONF=2.72
            if command -v autoconf >/dev/null 2>&1; then
              INST_VER=$(autoconf --version | head -n1 | awk '{print $NF}')
            else
              INST_VER=0
            fi

            if ! dpkg --compare-versions "$INST_VER" ge "$REQUIRED_AUTOCONF"; then
              echo "Autoconf $INST_VER < $REQUIRED_AUTOCONF â€” building autoconf-$REQUIRED_AUTOCONF from source"
              cd /tmp
              curl -fsSL "https://ftp.gnu.org/gnu/autoconf/autoconf-${REQUIRED_AUTOCONF}.tar.xz" -o autoconf-${REQUIRED_AUTOCONF}.tar.xz
              tar -xJf autoconf-${REQUIRED_AUTOCONF}.tar.xz
              cd autoconf-${REQUIRED_AUTOCONF}
              ./configure --prefix=/usr/local
              make -j$(nproc)
              sudo make install
              cd -
              hash -r || true
            else
              echo "autoconf $INST_VER >= $REQUIRED_AUTOCONF; skipping build"
            fi

            # Show autoconf version for CI debugging
            autoconf --version
          else
            brew update
            brew install autoconf automake libtool pkg-config openssl@3 jq libevent
            export PKG_CONFIG_PATH="$(brew --prefix openssl@3)/lib/pkgconfig:$(brew --prefix libevent)/lib/pkgconfig"
            export LDFLAGS="-L$(brew --prefix openssl@3)/lib -L$(brew --prefix libevent)/lib -Wl,-not_for_dyld_shared_cache"
            export CPPFLAGS="-I$(brew --prefix openssl@3)/include -I$(brew --prefix libevent)/include"
            export LD_SHARED_CACHE_ELIGIBLE=NO
            echo "PKG_CONFIG_PATH=$PKG_CONFIG_PATH" >> $GITHUB_ENV
            echo "LDFLAGS=$LDFLAGS" >> $GITHUB_ENV
            echo "CPPFLAGS=$CPPFLAGS" >> $GITHUB_ENV
            echo "LD_SHARED_CACHE_ELIGIBLE=$LD_SHARED_CACHE_ELIGIBLE" >> $GITHUB_ENV
          fi

      - name: Prepare build (autoreconf)
        shell: bash
        run: |
          autoreconf -fi

      - name: Configure
        shell: bash
        run: |
          ./configure --disable-ppp-plugin --prefix=/usr

      - name: Build & install into stagedir
        shell: bash
        run: |
          if [[ "$(uname)" == "Linux" ]]; then
            MAKEFLAGS=-j$(nproc)
          else
            MAKEFLAGS=-j$(sysctl -n hw.logicalcpu)
          fi
          make $MAKEFLAGS
          rm -rf dist
          make install DESTDIR=$PWD/dist

      - name: Package release tarball
        id: package
        shell: bash
        run: |
          mkdir -p release
          PKGDIR="${PKG_NAME}-${{ steps.vars.outputs.version }}-${{ matrix.name }}"
          mkdir -p "release/$PKGDIR"
          # copy installed files
          cp -a dist/* "release/$PKGDIR/" || true
          # include a small metadata file
          cat > "release/$PKGDIR/RELEASE_INFO" <<-EOF
          name: $PKG_NAME
          version: ${{ steps.vars.outputs.version }}
          flavor: ${{ matrix.name }}
          runner: ${{ matrix.runner }}
          arch: ${{ matrix.arch }}
          target: ${{ matrix.target }}
          built_at: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
          EOF
          ARTIFACT="${PKGDIR}.${{ matrix.ext }}"
          tar -C release -czf "$ARTIFACT" "$PKGDIR"
          echo "artifact=$ARTIFACT" >> "$GITHUB_OUTPUT"

      - name: Upload built artifact for release step
        uses: actions/upload-artifact@v6
        with:
          name: ${{ matrix.name }}
          path: ${{ steps.package.outputs.artifact }}

  release:
    name: Create / Upload Release
    runs-on: ubuntu-24.04
    needs: build
    steps:
      - name: Checkout
        uses: actions/checkout@v6
      - name: Download built artifacts
        uses: actions/download-artifact@v7
        with:
          # downloads all artifacts from previous job(s)
          path: artifacts

      - name: Determine release tag from artifacts
        id: get_version
        shell: bash
        run: |
          set -e
          # ensure jq is available for JSON fallback parsing
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update
            sudo apt-get install -y jq
          fi

          # Prefer linux amd64 artifact, else pick first archive
          ARCH=$(find artifacts -type f -name '*ubuntu-24.04-amd64*.tar.gz' -print -quit)
          if [ -z "$ARCH" ]; then
            ARCH=$(find artifacts -type f -name '*linux*amd64*.tar.gz' -print -quit)
          fi
          if [ -z "$ARCH" ]; then
            ARCH=$(find artifacts -type f -name '*.tar.gz' -print -quit)
          fi

          if [ -z "$ARCH" ]; then
            echo "No archives found to determine version" >&2
            if [ "$GITHUB_EVENT_NAME" = "release" ]; then
              VERSION=$(jq -r .release.tag_name < "$GITHUB_EVENT_PATH")
            else
              VERSION="${GITHUB_RUN_NUMBER}-nightly"
            fi
            TAG="$VERSION"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "tag=$TAG" >> $GITHUB_OUTPUT
            exit 0
          fi

          mkdir -p /tmp/release-check
          tar -xzf "$ARCH" -C /tmp/release-check

          # Find the sstpc binary and try to run it to get version
          BIN=$(find /tmp/release-check -type f -name sstpc -print -quit || true)
          VERSION=""
          if [ -n "$BIN" ] && file "$BIN" | grep -qi 'ELF\|executable'; then
            VERSION=$("$BIN" --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' || true)
          fi

          if [ -z "$VERSION" ]; then
            # Try RELEASE_INFO produced by packaging
            VERSION=$(grep -h '^version:' -m1 -R /tmp/release-check || true)
            VERSION=${VERSION#version: }
          fi

          if [ -z "$VERSION" ]; then
            if [ "$GITHUB_EVENT_NAME" = "release" ]; then
              VERSION=$(jq -r .release.tag_name < "$GITHUB_EVENT_PATH")
            else
              VERSION="${GITHUB_RUN_NUMBER}-nightly"
            fi
          fi

          # normalize (strip leading v if present)
          VERSION=${VERSION#v}

          if [ "$GITHUB_EVENT_NAME" = "release" ]; then
            TAG="$VERSION"
          else
            TAG="${VERSION}-nightly"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT

      - name: Create release_notes.md
        id: relvars
        shell: bash
        run: |
          cat > release_notes.md <<-EOF
          # Release ${{ steps.get_version.outputs.tag }}
          This is an automated release of **sstp-client**.
          ## Artifacts
          The following artifacts have been built and are attached to this release:
          $(ls -1 artifacts)
          EOF

      - name: Create or update release and upload assets
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e
          ls -lRa artifacts
          TAG=${{ steps.get_version.outputs.tag }}
          if ! gh release view "$TAG" >/dev/null 2>&1; then
            gh release create "$TAG" --title "sstp-client $TAG" --notes-file release_notes.md 
          fi
          ARCHIVES=$(find artifacts -type f \( -name '*.tar.gz' -o -name '*.zip' \) -print | paste -sd ' ' -)
          if [ -z "$ARCHIVES" ]; then
            echo "No archives found to upload"
          else
            echo "Uploading: $ARCHIVES"
            gh release upload "$TAG" $ARCHIVES --clobber
          fi
